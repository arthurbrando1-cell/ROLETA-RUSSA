<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roleta Russa 3D - Multiplayer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Bebas+Neue&family=Inter:wght@300;400;600;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a0a0a; 
            font-family: 'Inter', sans-serif; 
            color: #fff; 
            overflow: hidden;
            min-height: 100vh;
        }
        .font-horror { font-family: 'Creepster', cursive; }
        .font-display { font-family: 'Bebas Neue', sans-serif; }

        /* Animated Background */
        .bg-animated {
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(120, 0, 0, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(80, 0, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(20, 0, 0, 0.3) 0%, transparent 70%),
                linear-gradient(180deg, #0a0a0a 0%, #1a0505 50%, #0a0a0a 100%);
            z-index: -1;
        }
        .bg-animated::before {
            content: '';
            position: absolute;
            inset: 0;
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
        }

        /* Glass Card */
        .glass-card {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.9) 0%, rgba(10, 10, 10, 0.95) 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        /* Glow Effects */
        .glow-red { box-shadow: 0 0 30px rgba(200, 0, 0, 0.3), 0 0 60px rgba(150, 0, 0, 0.1); }
        .glow-text { text-shadow: 0 0 20px rgba(255, 50, 50, 0.5), 0 0 40px rgba(200, 0, 0, 0.3); }

        /* Custom Input */
        .input-dark {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .input-dark:focus {
            border-color: rgba(200, 50, 50, 0.5);
            box-shadow: 0 0 20px rgba(200, 50, 50, 0.2);
            outline: none;
        }

        /* Button Styles */
        .btn-primary {
            background: linear-gradient(135deg, #8b0000 0%, #5c0000 100%);
            border: 1px solid rgba(255, 100, 100, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .btn-primary::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .btn-primary:hover::before { opacity: 1; }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(139, 0, 0, 0.4);
        }
        .btn-primary:active { transform: translateY(0); }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Room Card */
        .room-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .room-card:hover {
            background: rgba(139, 0, 0, 0.1);
            border-color: rgba(139, 0, 0, 0.3);
            transform: translateX(5px);
        }

        /* Player Slot */
        .player-slot {
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .player-slot.occupied {
            background: rgba(139, 0, 0, 0.2);
            border: 2px solid rgba(139, 0, 0, 0.5);
        }
        .player-slot.is-turn {
            animation: pulse-border 1s infinite;
        }
        @keyframes pulse-border {
            0%, 100% { border-color: rgba(255, 0, 0, 0.5); box-shadow: 0 0 10px rgba(255, 0, 0, 0.3); }
            50% { border-color: rgba(255, 0, 0, 1); box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); }
        }

        /* 3D Canvas */
        #canvas-container { position: fixed; inset: 0; z-index: 0; }
        
        /* Vignette & Effects */
        .vignette {
            position: fixed; inset: 0;
            background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 1;
        }
        .blood-overlay {
            position: fixed; inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(100, 0, 0, 0.4) 100%);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none; z-index: 100;
        }
        .scanlines {
            position: fixed; inset: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 4px);
            pointer-events: none; z-index: 101; opacity: 0.3;
        }

        /* Player Badge 3D */
        .badge-3d {
            position: absolute;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: all 0.3s;
            white-space: nowrap;
        }
        .badge-3d.current-turn {
            border-color: #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            animation: pulse-badge 1s infinite;
        }
        .badge-3d.dead {
            opacity: 0.4;
            text-decoration: line-through;
            color: #666;
        }
        .badge-3d.talking {
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        @keyframes pulse-badge {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        ::-webkit-scrollbar-thumb { background: rgba(139, 0, 0, 0.5); border-radius: 3px; }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .animate-fadeIn { animation: fadeIn 0.5s ease forwards; }
        .animate-slideIn { animation: slideIn 0.3s ease forwards; }

        /* Mic Button */
        .mic-btn {
            width: 50px; height: 50px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        .mic-btn.active {
            background: rgba(0, 200, 0, 0.3) !important;
            border-color: #0f0 !important;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        /* Loading Spinner */
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #8b0000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="bg-animated"></div>

    <!-- ============ LOBBY SCREEN ============ -->
    <div id="lobby-screen" class="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="glass-card rounded-2xl w-full max-w-5xl overflow-hidden animate-fadeIn">
            
            <!-- Header -->
            <div class="p-8 border-b border-white/5 bg-gradient-to-r from-red-950/30 to-transparent">
                <div class="flex items-center justify-between">
                    <div>
                        <h1 class="font-horror text-5xl text-red-600 glow-text tracking-wider">ROLETA RUSSA</h1>
                        <p class="text-gray-500 mt-1 text-sm font-display tracking-widest">MULTIPLAYER ONLINE • 3D</p>
                    </div>
                    <div id="user-display" class="hidden text-right">
                        <p class="text-xs text-gray-500 uppercase">Jogando como</p>
                        <p id="my-name-display" class="text-xl font-bold text-white font-display"></p>
                    </div>
                </div>
            </div>

            <!-- Content -->
            <div class="p-8">
                
                <!-- LOGIN VIEW -->
                <div id="login-view" class="flex flex-col items-center justify-center py-16">
                    <div class="w-24 h-24 mb-8 rounded-full bg-gradient-to-br from-red-900 to-red-950 flex items-center justify-center glow-red">
                        <i class="fas fa-skull text-4xl text-red-400"></i>
                    </div>
                    <h2 class="text-2xl font-display text-gray-300 mb-6 tracking-wide">IDENTIFIQUE-SE</h2>
                    <input type="text" id="nickname-input" 
                        class="input-dark w-80 px-6 py-4 rounded-lg text-center text-xl font-bold uppercase tracking-wider mb-6"
                        placeholder="SEU NOME" maxlength="12">
                    <button id="btn-enter" class="btn-primary px-10 py-4 rounded-lg font-display text-xl tracking-widest">
                        <i class="fas fa-door-open mr-3"></i> ENTRAR
                    </button>
                    <p class="text-xs text-gray-600 mt-8 max-w-md text-center">
                        <i class="fas fa-exclamation-triangle text-red-800 mr-1"></i>
                        Jogo contém violência simulada. Apenas entretenimento.
                    </p>
                </div>

                <!-- ROOMS VIEW -->
                <div id="rooms-view" class="hidden">
                    <div class="grid grid-cols-3 gap-6">
                        
                        <!-- Rooms List -->
                        <div class="col-span-2">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="font-display text-xl text-gray-400 tracking-wider">
                                    <i class="fas fa-door-closed mr-2 text-red-700"></i> SALAS DISPONÍVEIS
                                </h3>
                                <button id="btn-refresh" class="text-gray-500 hover:text-white transition-colors">
                                    <i class="fas fa-sync-alt"></i>
                                </button>
                            </div>
                            <div id="rooms-list" class="space-y-2 max-h-96 overflow-y-auto pr-2">
                                <div class="flex items-center justify-center py-16 text-gray-600">
                                    <div class="spinner mr-4"></div>
                                    Buscando salas...
                                </div>
                            </div>
                        </div>

                        <!-- Create Room -->
                        <div class="glass-card rounded-xl p-6">
                            <h3 class="font-display text-xl text-gray-400 tracking-wider mb-6">
                                <i class="fas fa-plus-circle mr-2 text-red-700"></i> CRIAR SALA
                            </h3>
                            <input type="text" id="room-name-input" 
                                class="input-dark w-full px-4 py-3 rounded-lg text-sm mb-4"
                                placeholder="Nome da sala..." maxlength="20">
                            <button id="btn-create" class="btn-primary w-full py-3 rounded-lg font-display tracking-wider">
                                CRIAR
                            </button>
                            <div class="mt-6 pt-6 border-t border-white/5">
                                <div class="flex items-center text-xs text-gray-500 mb-2">
                                    <i class="fas fa-users mr-2"></i> Máx. 6 jogadores
                                </div>
                                <div class="flex items-center text-xs text-gray-500 mb-2">
                                    <i class="fas fa-microphone mr-2"></i> Chat de voz
                                </div>
                                <div class="flex items-center text-xs text-gray-500">
                                    <i class="fas fa-skull-crossbones mr-2"></i> Modo eliminação
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- ============ WAITING ROOM ============ -->
    <div id="waiting-room" class="fixed inset-0 z-40 hidden flex items-center justify-center p-4">
        <div class="glass-card rounded-2xl w-full max-w-3xl overflow-hidden animate-fadeIn">
            <div class="p-6 border-b border-white/5 flex items-center justify-between">
                <div>
                    <p class="text-xs text-gray-500 uppercase">Sala</p>
                    <h2 id="current-room-name" class="text-2xl font-display text-white"></h2>
                </div>
                <button id="btn-leave-room" class="btn-secondary px-4 py-2 rounded-lg text-sm">
                    <i class="fas fa-sign-out-alt mr-2"></i> Sair
                </button>
            </div>
            
            <div class="p-6">
                <h3 class="text-sm text-gray-500 uppercase mb-4">Jogadores na Mesa</h3>
                <div id="players-grid" class="grid grid-cols-3 gap-4 mb-6">
                    <!-- Slots gerados via JS -->
                </div>
                
                <div id="host-controls" class="hidden border-t border-white/5 pt-6">
                    <button id="btn-start-match" class="btn-primary w-full py-4 rounded-lg font-display text-xl tracking-widest disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fas fa-play mr-2"></i> INICIAR PARTIDA
                    </button>
                    <p class="text-center text-xs text-gray-500 mt-2">Mínimo 2 jogadores</p>
                </div>
                
                <div id="guest-waiting" class="text-center py-4">
                    <div class="spinner mx-auto mb-4"></div>
                    <p class="text-gray-400">Aguardando o host iniciar...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- ============ GAME HUD ============ -->
    <div id="game-hud" class="fixed inset-0 z-30 hidden pointer-events-none">
        <div class="absolute inset-0 p-6 flex flex-col justify-between">
            
            <!-- Top Bar -->
            <div class="flex justify-between items-start pointer-events-auto">
                <button id="btn-leave-game" class="btn-secondary px-4 py-2 rounded-lg text-sm">
                    <i class="fas fa-arrow-left mr-2"></i> Sair
                </button>
                
                <div class="flex items-center gap-4">
                    <div id="voice-indicator" class="text-xs text-gray-500 uppercase">
                        <i class="fas fa-microphone-slash mr-1"></i> Mudo
                    </div>
                    <button id="btn-mic" class="mic-btn btn-secondary pointer-events-auto">
                        <i class="fas fa-microphone-slash"></i>
                    </button>
                </div>
            </div>

            <!-- Center Message -->
            <div id="game-message" class="text-center opacity-0 transition-all duration-300">
                <h2 id="msg-text" class="font-horror text-6xl text-red-600 glow-text"></h2>
            </div>

            <!-- Bottom Controls -->
            <div class="flex justify-center pb-8">
                <button id="btn-trigger" class="hidden pointer-events-auto btn-primary px-16 py-6 rounded-xl font-horror text-3xl tracking-widest transform hover:scale-105 transition-transform">
                    <i class="fas fa-hand-pointer mr-3"></i> PUXAR GATILHO
                </button>
                
                <div id="spectating-msg" class="hidden text-center">
                    <p class="text-gray-400 text-lg">Você está observando...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 3D Labels Container -->
    <div id="labels-3d" class="fixed inset-0 pointer-events-none z-20"></div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>
    
    <!-- Effects -->
    <div class="vignette"></div>
    <div id="blood-overlay" class="blood-overlay"></div>
    <div class="scanlines"></div>

    <!-- ============ SCRIPTS ============ -->
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, push, get, update, remove, onValue, onDisconnect } 
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyCfdgkO3WzaxXT-djAA6MsLC2m26c9optU",
            authDomain: "slider-io.firebaseapp.com",
            databaseURL: "https://slider-io-default-rtdb.firebaseio.com",
            projectId: "slider-io",
            storageBucket: "slider-io.firebasestorage.app",
            messagingSenderId: "395647141464",
            appId: "1:395647141464:web:251cc58a3e0e90ca262c2d"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // ====== STATE ======
        let myId = localStorage.getItem('rr_id') || 'u_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('rr_id', myId);
        let myName = "";
        let currentRoom = null;
        let isHost = false;
        let mySlot = -1;
        let unsubscribers = [];

        // 3D State
        let scene, camera, renderer, clock;
        let playerMeshes = {};
        let gunGroup, cylinderMesh;
        let particles = [];
        let audioCtx;

        // DOM Elements
        const $lobby = document.getElementById('lobby-screen');
        const $loginView = document.getElementById('login-view');
        const $roomsView = document.getElementById('rooms-view');
        const $roomsList = document.getElementById('rooms-list');
        const $waitingRoom = document.getElementById('waiting-room');
        const $playersGrid = document.getElementById('players-grid');
        const $gameHud = document.getElementById('game-hud');
        const $labels3d = document.getElementById('labels-3d');
        const $msgText = document.getElementById('msg-text');
        const $gameMessage = document.getElementById('game-message');
        const $bloodOverlay = document.getElementById('blood-overlay');

        // ====== LOBBY LOGIC ======

        document.getElementById('btn-enter').onclick = () => {
            const name = document.getElementById('nickname-input').value.trim();
            if (!name) return;
            myName = name.toUpperCase();
            document.getElementById('my-name-display').textContent = myName;
            document.getElementById('user-display').classList.remove('hidden');
            $loginView.classList.add('hidden');
            $roomsView.classList.remove('hidden');
            listenToRooms();
        };

        document.getElementById('btn-create').onclick = async () => {
            const name = document.getElementById('room-name-input').value.trim() || `Sala de ${myName}`;
            const roomRef = push(ref(db, 'rooms'));
            await set(roomRef, {
                name: name,
                hostId: myId,
                hostName: myName,
                status: 'waiting',
                createdAt: Date.now()
            });
            joinRoom(roomRef.key);
        };

        document.getElementById('btn-refresh').onclick = () => listenToRooms();

        function listenToRooms() {
            onValue(ref(db, 'rooms'), (snap) => {
                $roomsList.innerHTML = '';
                const rooms = snap.val();
                if (!rooms) {
                    $roomsList.innerHTML = '<p class="text-center text-gray-600 py-8">Nenhuma sala encontrada</p>';
                    return;
                }
                
                Object.entries(rooms).forEach(([id, room], idx) => {
                    const count = room.players ? Object.keys(room.players).length : 0;
                    const isFull = count >= 6;
                    const isPlaying = room.status === 'playing';
                    
                    const div = document.createElement('div');
                    div.className = `room-card rounded-lg p-4 flex items-center justify-between animate-slideIn`;
                    div.style.animationDelay = `${idx * 0.05}s`;
                    div.innerHTML = `
                        <div class="flex items-center gap-4">
                            <div class="w-10 h-10 rounded-full bg-red-900/30 flex items-center justify-center">
                                <i class="fas fa-door-open text-red-500"></i>
                            </div>
                            <div>
                                <p class="font-bold text-white">${room.name}</p>
                                <p class="text-xs text-gray-500">Host: ${room.hostName}</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-4">
                            ${isPlaying ? '<span class="text-xs text-yellow-500 uppercase"><i class="fas fa-gamepad mr-1"></i>Em jogo</span>' : ''}
                            <span class="text-sm ${isFull ? 'text-red-500' : 'text-green-500'}">${count}/6</span>
                            <i class="fas fa-chevron-right text-gray-600"></i>
                        </div>
                    `;
                    if (!isFull && !isPlaying) {
                        div.onclick = () => joinRoom(id);
                    } else {
                        div.style.opacity = '0.5';
                        div.style.cursor = 'not-allowed';
                    }
                    $roomsList.appendChild(div);
                });
            }, { onlyOnce: true });
        }

        async function joinRoom(roomId) {
            const snap = await get(ref(db, `rooms/${roomId}`));
            const room = snap.val();
            if (!room) return;
            
            const players = room.players || {};
            const count = Object.keys(players).length;
            if (count >= 6) return alert("Sala cheia!");

            // Find slot
            const takenSlots = Object.values(players).map(p => p.slot);
            mySlot = 0;
            while (takenSlots.includes(mySlot)) mySlot++;

            currentRoom = roomId;
            isHost = room.hostId === myId;

            // Register player
            const playerRef = ref(db, `rooms/${roomId}/players/${myId}`);
            await set(playerRef, {
                name: myName,
                slot: mySlot,
                isDead: false,
                isTalking: false
            });
            onDisconnect(playerRef).remove();

            // UI
            $lobby.classList.add('hidden');
            $waitingRoom.classList.remove('hidden');
            document.getElementById('current-room-name').textContent = room.name;

            if (isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('guest-waiting').classList.add('hidden');
            }

            // Generate slots
            $playersGrid.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                slot.id = `slot-${i}`;
                slot.className = 'player-slot rounded-lg p-4 text-center h-24 flex flex-col items-center justify-center';
                slot.innerHTML = `<i class="fas fa-user-slash text-2xl text-gray-700"></i><p class="text-xs text-gray-600 mt-2">Vazio</p>`;
                $playersGrid.appendChild(slot);
            }

            // Listen to room changes
            const unsub = onValue(ref(db, `rooms/${roomId}`), (snap) => {
                const data = snap.val();
                if (!data) {
                    // Room deleted
                    leaveRoom();
                    return;
                }
                
                updateWaitingRoom(data);
                
                if (data.status === 'playing') {
                    startGame(data);
                }
            });
            unsubscribers.push(unsub);
        }

        function updateWaitingRoom(room) {
            const players = room.players || {};
            const count = Object.keys(players).length;

            // Clear slots
            for (let i = 0; i < 6; i++) {
                const slot = document.getElementById(`slot-${i}`);
                slot.className = 'player-slot rounded-lg p-4 text-center h-24 flex flex-col items-center justify-center';
                slot.innerHTML = `<i class="fas fa-user-slash text-2xl text-gray-700"></i><p class="text-xs text-gray-600 mt-2">Vazio</p>`;
            }

            // Fill slots
            Object.entries(players).forEach(([pid, p]) => {
                const slot = document.getElementById(`slot-${p.slot}`);
                slot.classList.add('occupied');
                const isMe = pid === myId;
                slot.innerHTML = `
                    <div class="w-10 h-10 rounded-full ${isMe ? 'bg-red-700' : 'bg-gray-700'} flex items-center justify-center mb-2">
                        <i class="fas fa-user text-white"></i>
                    </div>
                    <p class="text-sm font-bold ${isMe ? 'text-red-400' : 'text-white'}">${p.name}</p>
                    ${pid === room.hostId ? '<span class="text-xs text-yellow-500"><i class="fas fa-crown"></i></span>' : ''}
                `;
            });

            // Start button
            const startBtn = document.getElementById('btn-start-match');
            startBtn.disabled = count < 2;
        }

        document.getElementById('btn-leave-room').onclick = leaveRoom;
        document.getElementById('btn-leave-game').onclick = leaveRoom;

        function leaveRoom() {
            if (currentRoom) {
                remove(ref(db, `rooms/${currentRoom}/players/${myId}`));
                
                // Clean up room if empty
                get(ref(db, `rooms/${currentRoom}/players`)).then((snap) => {
                    if (!snap.exists()) {
                        remove(ref(db, `rooms/${currentRoom}`));
                    }
                });
            }
            
            unsubscribers.forEach(unsub => unsub());
            unsubscribers = [];
            
            currentRoom = null;
            mySlot = -1;
            
            $waitingRoom.classList.add('hidden');
            $gameHud.classList.add('hidden');
            $lobby.classList.remove('hidden');
            
            reset3D();
        }

        document.getElementById('btn-start-match').onclick = async () => {
            const bullet = Math.floor(Math.random() * 6);
            await update(ref(db, `rooms/${currentRoom}`), {
                status: 'playing',
                bulletPos: bullet,
                chamber: 0,
                turnSlot: 0,
                lastAction: { type: 'start', time: Date.now() }
            });
        };

        // ====== GAME LOGIC ======

        function startGame(room) {
            $waitingRoom.classList.add('hidden');
            $gameHud.classList.remove('hidden');
            
            init3D();
            setupGameListeners();
            showMessage("QUE COMECE O JOGO", 2000);
        }

        function setupGameListeners() {
            onValue(ref(db, `rooms/${currentRoom}`), (snap) => {
                const room = snap.val();
                if (!room || room.status !== 'playing') return;
                
                updateGame(room);
            });
        }

        function updateGame(room) {
            const players = room.players || {};
            
            // Update 3D players
            update3DPlayers(players, room.turnSlot);
            
            // Rotate gun
            rotateGunToSlot(room.turnSlot);
            
            // Check if my turn
            const me = players[myId];
            if (me && !me.isDead && me.slot === room.turnSlot) {
                document.getElementById('btn-trigger').classList.remove('hidden');
                document.getElementById('spectating-msg').classList.add('hidden');
            } else {
                document.getElementById('btn-trigger').classList.add('hidden');
                if (me && me.isDead) {
                    document.getElementById('spectating-msg').classList.remove('hidden');
                }
            }
            
            // Handle last action
            if (room.lastAction && Date.now() - room.lastAction.time < 2000) {
                if (room.lastAction.type === 'bang') {
                    handleBang(room.lastAction.slot, players);
                } else if (room.lastAction.type === 'click') {
                    handleClick();
                }
            }
        }

        document.getElementById('btn-trigger').onclick = async () => {
            document.getElementById('btn-trigger').classList.add('hidden');
            
            const snap = await get(ref(db, `rooms/${currentRoom}`));
            const room = snap.val();
            const players = room.players || {};
            
            const isBang = room.chamber === room.bulletPos;
            
            if (isBang) {
                await update(ref(db, `rooms/${currentRoom}`), {
                    lastAction: { type: 'bang', slot: mySlot, time: Date.now() },
                    [`players/${myId}/isDead`]: true
                });
            } else {
                const nextSlot = findNextAliveSlot(players, room.turnSlot);
                await update(ref(db, `rooms/${currentRoom}`), {
                    lastAction: { type: 'click', slot: mySlot, time: Date.now() },
                    chamber: room.chamber + 1,
                    turnSlot: nextSlot
                });
            }
        };

        function findNextAliveSlot(players, currentSlot) {
            const sorted = Object.entries(players)
                .map(([id, p]) => ({ id, ...p }))
                .filter(p => !p.isDead)
                .sort((a, b) => a.slot - b.slot);
            
            if (sorted.length === 0) return currentSlot;
            
            for (let p of sorted) {
                if (p.slot > currentSlot) return p.slot;
            }
            return sorted[0].slot;
        }

        function handleBang(slot, players) {
            playSound('bang');
            
            // Find victim
            const victim = Object.entries(players).find(([id, p]) => p.slot === slot);
            if (victim) {
                const [victimId, victimData] = victim;
                
                // 3D Effect
                const mesh = playerMeshes[victimId];
                if (mesh && mesh.userData.headGroup) {
                    mesh.userData.headGroup.visible = false;
                    createBloodExplosion(mesh.position.clone().add(new THREE.Vector3(0, 8, 0)));
                    
                    // Fall animation
                    let fall = 0;
                    const fallInterval = setInterval(() => {
                        fall += 0.15;
                        mesh.rotation.x = -Math.min(fall, 1.5);
                        if (fall >= 1.5) clearInterval(fallInterval);
                    }, 16);
                }
                
                // Screen effect
                if (victimId === myId) {
                    $bloodOverlay.style.opacity = 1;
                    showMessage("VOCÊ MORREU", 3000);
                    setTimeout(() => $bloodOverlay.style.opacity = 0, 3000);
                } else {
                    showMessage(`${victimData.name} MORREU`, 2000);
                }
            }
            
            // Gun recoil
            if (gunGroup) {
                gunGroup.rotation.x = -0.5;
                setTimeout(() => gunGroup.rotation.x = 0, 200);
            }
        }

        function handleClick() {
            playSound('click');
            if (cylinderMesh) {
                cylinderMesh.rotation.z += Math.PI / 3;
            }
            showMessage("CLICK", 1000);
        }

        function showMessage(text, duration) {
            $msgText.textContent = text;
            $gameMessage.style.opacity = 1;
            setTimeout(() => $gameMessage.style.opacity = 0, duration);
        }

        // ====== 3D ENGINE ======

        function init3D() {
            if (renderer) return;
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0505, 0.025);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0x1a0505, 0.3);
            scene.add(ambient);
            
            const spot = new THREE.SpotLight(0xffeedd, 1.5);
            spot.position.set(0, 30, 0);
            spot.angle = Math.PI / 4;
            spot.penumbra = 0.8;
            spot.castShadow = true;
            spot.shadow.mapSize.set(2048, 2048);
            scene.add(spot);
            
            const redLight = new THREE.PointLight(0x660000, 0.5, 30);
            redLight.position.set(-15, 5, -15);
            scene.add(redLight);
            
            // Table
            const tableGeo = new THREE.CylinderGeometry(12, 12, 1, 64);
            const tableMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.8,
                metalness: 0.2
            });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.y = -1;
            table.receiveShadow = true;
            scene.add(table);
            
            // Felt
            const feltGeo = new THREE.CircleGeometry(11.5, 64);
            feltGeo.rotateX(-Math.PI / 2);
            const feltMat = new THREE.MeshStandardMaterial({ color: 0x0a1a0a, roughness: 1 });
            const felt = new THREE.Mesh(feltGeo, feltMat);
            felt.position.y = -0.49;
            felt.receiveShadow = true;
            scene.add(felt);
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 1 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -10;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Gun
            createGun();
            
            clock = new THREE.Clock();
            window.addEventListener('resize', onResize);
            animate();
        }

        function createGun() {
            gunGroup = new THREE.Group();
            const metal = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.95, roughness: 0.15 });
            const grip = new THREE.MeshStandardMaterial({ color: 0x3d1e10, roughness: 0.8 });
            
            // Barrel
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 5, 16), metal);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.z = 2.5;
            barrel.castShadow = true;
            gunGroup.add(barrel);
            
            // Barrel hole
            const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.5, 16), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            hole.rotation.x = Math.PI / 2;
            hole.position.z = 5;
            gunGroup.add(hole);
            
            // Cylinder
            cylinderMesh = new THREE.Group();
            const cylBody = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.1, 1.8, 24), metal);
            cylBody.rotation.x = Math.PI / 2;
            cylBody.castShadow = true;
            cylinderMesh.add(cylBody);
            
            for (let i = 0; i < 6; i++) {
                const a = (i / 6) * Math.PI * 2;
                const ch = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 1.85, 12), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                ch.rotation.x = Math.PI / 2;
                ch.position.set(Math.cos(a) * 0.6, Math.sin(a) * 0.6, 0);
                cylinderMesh.add(ch);
            }
            gunGroup.add(cylinderMesh);
            
            // Frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(1.4, 2.2, 3.5), metal);
            frame.position.set(0, -0.6, -1);
            frame.castShadow = true;
            gunGroup.add(frame);
            
            // Grip
            const gripMesh = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2.8, 1.4), grip);
            gripMesh.position.set(0, -1.8, -2.8);
            gripMesh.rotation.x = 0.4;
            gripMesh.castShadow = true;
            gunGroup.add(gripMesh);
            
            // Hammer
            const hammer = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.4), metal);
            hammer.position.set(0, 0.8, -2);
            gunGroup.add(hammer);
            
            // Trigger
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.6, 0.3), metal);
            trigger.position.set(0, -1.2, -1.2);
            trigger.rotation.x = -0.3;
            gunGroup.add(trigger);
            
            gunGroup.position.y = 0.5;
            gunGroup.scale.set(1.2, 1.2, 1.2);
            scene.add(gunGroup);
        }

        function createPlayerMesh(id, data) {
            const group = new THREE.Group();
            const angle = data.slot * (Math.PI * 2 / 6) - Math.PI / 2;
            const radius = 14;
            
            group.position.set(
                Math.cos(angle) * radius,
                -5,
                Math.sin(angle) * radius
            );
            group.lookAt(0, -3, 0);
            
            // Colors by slot
            const colors = [0x8b0000, 0x006400, 0x00008b, 0x8b8b00, 0x008b8b, 0x8b008b];
            const skinTone = 0xe0c8b8;
            
            const clothMat = new THREE.MeshStandardMaterial({ color: colors[data.slot] || 0x333333, roughness: 0.8 });
            const skinMat = new THREE.MeshStandardMaterial({ color: skinTone, roughness: 0.6 });
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            
            // Body
            const torso = new THREE.Mesh(new THREE.BoxGeometry(4, 5.5, 2.2), clothMat);
            torso.position.y = 3;
            torso.castShadow = true;
            group.add(torso);
            
            // Shoulders
            const shoulderL = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), clothMat);
            shoulderL.position.set(-2.4, 5, 0);
            group.add(shoulderL);
            
            const shoulderR = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), clothMat);
            shoulderR.position.set(2.4, 5, 0);
            group.add(shoulderR);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.5, 0.45, 4, 12);
            const armL = new THREE.Mesh(armGeo, clothMat);
            armL.position.set(-2.8, 3, 1.5);
            armL.rotation.x = -1;
            armL.rotation.z = 0.2;
            group.add(armL);
            
            const armR = new THREE.Mesh(armGeo, clothMat);
            armR.position.set(2.8, 3, 1.5);
            armR.rotation.x = -1;
            armR.rotation.z = -0.2;
            group.add(armR);
            
            // Hands
            const handGeo = new THREE.SphereGeometry(0.55, 10, 10);
            const handL = new THREE.Mesh(handGeo, skinMat);
            handL.position.set(-2.5, 1.5, 4);
            group.add(handL);
            
            const handR = new THREE.Mesh(handGeo, skinMat);
            handR.position.set(2.5, 1.5, 4);
            group.add(handR);
            
            // Neck
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.7, 1, 12), skinMat);
            neck.position.y = 6;
            group.add(neck);
            
            // Head Group
            const headGroup = new THREE.Group();
            headGroup.position.y = 7.5;
            group.add(headGroup);
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.4, 20, 20), skinMat);
            head.scale.set(1, 1.15, 1);
            head.castShadow = true;
            headGroup.add(head);
            
            // Face features
            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.18, 8, 8);
            const eyeWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyeBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const eyeL = new THREE.Mesh(eyeGeo, eyeWhite);
            eyeL.position.set(-0.45, 0.15, 1.2);
            headGroup.add(eyeL);
            
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), eyeBlack);
            pupilL.position.set(-0.45, 0.15, 1.35);
            headGroup.add(pupilL);
            
            const eyeR = new THREE.Mesh(eyeGeo, eyeWhite);
            eyeR.position.set(0.45, 0.15, 1.2);
            headGroup.add(eyeR);
            
            const pupilR = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), eyeBlack);
            pupilR.position.set(0.45, 0.15, 1.35);
            headGroup.add(pupilR);
            
            // Eyebrows
            const browGeo = new THREE.BoxGeometry(0.4, 0.08, 0.1);
            const browMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            const browL = new THREE.Mesh(browGeo, browMat);
            browL.position.set(-0.45, 0.45, 1.3);
            browL.rotation.z = 0.1;
            headGroup.add(browL);
            
            const browR = new THREE.Mesh(browGeo, browMat);
            browR.position.set(0.45, 0.45, 1.3);
            browR.rotation.z = -0.1;
            headGroup.add(browR);
            
            // Nose
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.35, 8), skinMat);
            nose.position.set(0, -0.1, 1.35);
            nose.rotation.x = Math.PI / 2;
            headGroup.add(nose);
            
            // Mouth
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.05), new THREE.MeshBasicMaterial({ color: 0x8b4040 }));
            mouth.position.set(0, -0.5, 1.3);
            headGroup.add(mouth);
            
            // Hair
            const hair = new THREE.Mesh(new THREE.SphereGeometry(1.45, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2.2), hairMat);
            hair.position.y = 0.3;
            hair.rotation.x = -0.2;
            headGroup.add(hair);
            
            // Store references
            group.userData = { 
                id, 
                slot: data.slot, 
                headGroup, 
                isDead: data.isDead,
                offset: Math.random() * 100
            };
            
            if (data.isDead) {
                headGroup.visible = false;
                group.rotation.x = -1.5;
            }
            
            scene.add(group);
            playerMeshes[id] = group;
            
            // Create label
            createLabel(id, data);
            
            return group;
        }

        function createLabel(id, data) {
            const label = document.createElement('div');
            label.id = `label-${id}`;
            label.className = 'badge-3d';
            label.innerHTML = `<i class="fas fa-user mr-1"></i>${data.name}`;
            if (id === myId) label.innerHTML += ' <span class="text-red-400">(você)</span>';
            $labels3d.appendChild(label);
        }

        function update3DPlayers(players, turnSlot) {
            // Remove old meshes
            Object.keys(playerMeshes).forEach(id => {
                if (!players[id]) {
                    scene.remove(playerMeshes[id]);
                    delete playerMeshes[id];
                    const label = document.getElementById(`label-${id}`);
                    if (label) label.remove();
                }
            });
            
            // Add/update meshes
            Object.entries(players).forEach(([id, data]) => {
                if (!playerMeshes[id]) {
                    createPlayerMesh(id, data);
                }
                
                const mesh = playerMeshes[id];
                const label = document.getElementById(`label-${id}`);
                
                if (label) {
                    label.classList.toggle('current-turn', data.slot === turnSlot && !data.isDead);
                    label.classList.toggle('dead', data.isDead);
                    label.classList.toggle('talking', data.isTalking);
                }
                
                if (data.isDead && mesh.userData.headGroup.visible) {
                    mesh.userData.headGroup.visible = false;
                }
            });
            
            // Position camera
            const myPlayer = players[myId];
            if (myPlayer) {
                const angle = myPlayer.slot * (Math.PI * 2 / 6) - Math.PI / 2;
                const camX = Math.cos(angle) * 25;
                const camZ = Math.sin(angle) * 25;
                camera.position.set(camX, 12, camZ);
                camera.lookAt(0, 0, 0);
            }
        }

        function rotateGunToSlot(slot) {
            if (!gunGroup) return;
            const angle = slot * (Math.PI * 2 / 6) - Math.PI / 2;
            gunGroup.rotation.y = -angle;
        }

        function createBloodExplosion(pos) {
            const geo = new THREE.BufferGeometry();
            const count = 150;
            const positions = [];
            const velocities = [];
            
            for (let i = 0; i < count; i++) {
                positions.push(pos.x, pos.y, pos.z);
                velocities.push(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 12,
                    (Math.random() - 0.5) * 15
                );
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0x880000, size: 0.4, transparent: true });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            particles.push({ mesh: points, vels: velocities, age: 0 });
            
            // Chunks
            for (let i = 0; i < 8; i++) {
                const chunk = new THREE.Mesh(
                    new THREE.BoxGeometry(Math.random() * 0.4 + 0.2, Math.random() * 0.4 + 0.2, Math.random() * 0.4 + 0.2),
                    new THREE.MeshStandardMaterial({ color: 0x550000, roughness: 0.3 })
                );
                chunk.position.copy(pos);
                scene.add(chunk);
                particles.push({
                    mesh: chunk,
                    vel: new THREE.Vector3((Math.random() - 0.5) * 10, Math.random() * 8, (Math.random() - 0.5) * 10),
                    age: 0,
                    isChunk: true
                });
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.age += dt;
                
                if (p.isChunk) {
                    p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                    p.vel.y -= 15 * dt;
                    p.mesh.rotation.x += dt * 3;
                    p.mesh.rotation.z += dt * 3;
                    
                    if (p.age > 3) {
                        scene.remove(p.mesh);
                        particles.splice(i, 1);
                    }
                } else {
                    const positions = p.mesh.geometry.attributes.position.array;
                    for (let j = 0; j < p.vels.length / 3; j++) {
                        positions[j * 3] += p.vels[j * 3] * dt;
                        positions[j * 3 + 1] += p.vels[j * 3 + 1] * dt;
                        positions[j * 3 + 2] += p.vels[j * 3 + 2] * dt;
                        p.vels[j * 3 + 1] -= 15 * dt;
                    }
                    p.mesh.geometry.attributes.position.needsUpdate = true;
                    p.mesh.material.opacity = 1 - p.age / 1.5;
                    
                    if (p.age > 1.5) {
                        scene.remove(p.mesh);
                        particles.splice(i, 1);
                    }
                }
            }
            
            // Animate players
            Object.values(playerMeshes).forEach(mesh => {
                if (mesh.userData.isDead) return;
                
                const offset = mesh.userData.offset;
                const breath = Math.sin(time * 2 + offset) * 0.03;
                mesh.position.y = -5 + breath;
                
                if (mesh.userData.headGroup) {
                    mesh.userData.headGroup.rotation.y = Math.sin(time * 0.5 + offset) * 0.1;
                    mesh.userData.headGroup.rotation.x = Math.sin(time * 0.3 + offset) * 0.05;
                }
            });
            
            // Update labels
            Object.entries(playerMeshes).forEach(([id, mesh]) => {
                const label = document.getElementById(`label-${id}`);
                if (!label) return;
                
                const pos = mesh.position.clone();
                pos.y += 11;
                pos.project(camera);
                
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
                label.style.display = pos.z > 1 ? 'none' : 'block';
            });
            
            renderer.render(scene, camera);
        }

        function reset3D() {
            Object.values(playerMeshes).forEach(m => scene.remove(m));
            playerMeshes = {};
            $labels3d.innerHTML = '';
        }

        // ====== AUDIO ======

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioCtx) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const now = audioCtx.currentTime;
            
            if (type === 'click') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(1000, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'bang') {
                // Low thud
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(60, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                gain.gain.setValueAtTime(1.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
                
                // Noise
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.4, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 1.5);
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(0.8, now);
                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noise.start(now);
            }
        }

        // ====== MIC ======

        let micStream = null;
        let isMuted = true;

        document.getElementById('btn-mic').onclick = async () => {
            if (!micStream) {
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micStream.getAudioTracks()[0].enabled = false;
                } catch (e) {
                    console.error('Mic error:', e);
                    return;
                }
            }
            
            isMuted = !isMuted;
            micStream.getAudioTracks()[0].enabled = !isMuted;
            
            const btn = document.getElementById('btn-mic');
            const indicator = document.getElementById('voice-indicator');
            
            if (isMuted) {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
                indicator.innerHTML = '<i class="fas fa-microphone-slash mr-1"></i> Mudo';
                if (currentRoom) {
                    update(ref(db, `rooms/${currentRoom}/players/${myId}/isTalking`), false);
                }
            } else {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-microphone"></i>';
                indicator.innerHTML = '<i class="fas fa-microphone mr-1"></i> Ao Vivo';
                
                // Detect talking
                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(micStream);
                const analyzer = audioContext.createAnalyser();
                source.connect(analyzer);
                analyzer.fftSize = 256;
                const dataArray = new Uint8Array(analyzer.frequencyBinCount);
                
                function checkTalking() {
                    if (isMuted) return;
                    analyzer.getByteFrequencyData(dataArray);
                    const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    if (currentRoom) {
                        update(ref(db, `rooms/${currentRoom}/players/${myId}/isTalking`), avg > 15);
                    }
                    requestAnimationFrame(checkTalking);
                }
                checkTalking();
            }
        };

    </script>
</body>
</html>
