<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROLETA RUSSA - Multiplayer Extremo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Orbitron:wght@400;700;900&family=Russo+One&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Orbitron', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            min-height: 100vh;
        }

        .font-horror { font-family: 'Creepster', cursive; }
        .font-russo { font-family: 'Russo One', sans-serif; }

        /* Animated Background */
        .bg-animated {
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(80, 0, 0, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(60, 0, 0, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(20, 0, 0, 0.5) 0%, transparent 70%),
                linear-gradient(180deg, #0a0000 0%, #000000 50%, #050000 100%);
            z-index: -2;
        }

        /* Blood Rain */
        .blood-rain {
            position: fixed;
            inset: 0;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
        }
        .blood-drop {
            position: absolute;
            width: 3px;
            height: 20px;
            background: linear-gradient(to bottom, transparent, #8b0000, #ff0000);
            border-radius: 50%;
            animation: bloodFall linear infinite;
            opacity: 0.6;
        }
        @keyframes bloodFall {
            0% { transform: translateY(-100vh) rotate(15deg); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { transform: translateY(100vh) rotate(15deg); opacity: 0; }
        }

        /* Scanlines */
        .scanlines {
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.3) 2px,
                rgba(0, 0, 0, 0.3) 4px
            );
            pointer-events: none;
            z-index: 1000;
            opacity: 0.1;
        }

        /* Vignette */
        .vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.9) 100%);
            pointer-events: none;
            z-index: 999;
        }

        /* Glass Card */
        .glass-card {
            background: linear-gradient(135deg, rgba(20, 0, 0, 0.95) 0%, rgba(5, 0, 0, 0.98) 100%);
            border: 1px solid rgba(255, 0, 0, 0.15);
            backdrop-filter: blur(20px);
            box-shadow: 
                0 25px 80px rgba(0, 0, 0, 0.9),
                0 0 150px rgba(100, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.02),
                inset 0 0 100px rgba(100, 0, 0, 0.05);
        }

        /* Neon Border Animation */
        .neon-border {
            position: relative;
        }
        .neon-border::before {
            content: '';
            position: absolute;
            inset: -3px;
            background: linear-gradient(45deg, #ff0000, #330000, #ff0000, #660000, #ff0000);
            background-size: 400% 400%;
            border-radius: inherit;
            z-index: -1;
            animation: neonPulse 4s ease infinite;
            filter: blur(8px);
            opacity: 0.6;
        }
        @keyframes neonPulse {
            0%, 100% { background-position: 0% 50%; opacity: 0.6; }
            50% { background-position: 100% 50%; opacity: 0.9; }
        }

        /* Input */
        .input-dark {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 0, 0, 0.2);
            color: #fff;
            transition: all 0.3s ease;
        }
        .input-dark:focus {
            outline: none;
            border-color: rgba(255, 0, 0, 0.7);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), inset 0 0 30px rgba(255, 0, 0, 0.05);
        }

        /* Buttons */
        .btn-blood {
            background: linear-gradient(135deg, #8b0000 0%, #3d0000 50%, #8b0000 100%);
            background-size: 200% 200%;
            border: 2px solid rgba(255, 50, 50, 0.4);
            color: #fff;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: btnPulse 3s ease infinite;
        }
        @keyframes btnPulse {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .btn-blood::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            transition: left 0.5s;
        }
        .btn-blood:hover::before {
            left: 100%;
        }
        .btn-blood:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 15px 40px rgba(139, 0, 0, 0.6), 0 0 60px rgba(255, 0, 0, 0.3);
        }

        .btn-ghost {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        .btn-ghost:hover {
            border-color: rgba(255, 0, 0, 0.6);
            color: #fff;
            background: rgba(255, 0, 0, 0.1);
        }

        /* Room Card */
        .room-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.4s ease;
            cursor: pointer;
        }
        .room-card:hover {
            background: rgba(139, 0, 0, 0.3);
            border-color: rgba(139, 0, 0, 0.6);
            transform: translateX(10px) scale(1.02);
            box-shadow: 0 10px 40px rgba(139, 0, 0, 0.3);
        }

        /* Avatar Selection */
        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            background: rgba(0,0,0,0.5);
        }
        .avatar-option:hover {
            transform: scale(1.15);
            border-color: rgba(255,0,0,0.5);
        }
        .avatar-option.selected {
            border-color: #ff0000;
            box-shadow: 0 0 20px rgba(255,0,0,0.6);
        }

        /* Player Slot */
        .player-slot {
            background: rgba(0, 0, 0, 0.6);
            border: 2px dashed rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .player-slot.occupied {
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.4) 0%, rgba(60, 0, 0, 0.6) 100%);
            border: 2px solid rgba(139, 0, 0, 0.7);
        }
        .player-slot.is-me {
            border-color: #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
        }

        /* 3D Labels */
        .label-3d {
            position: absolute;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: all 0.3s;
            white-space: nowrap;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .label-3d .avatar-emoji {
            font-size: 20px;
        }
        .label-3d.current-turn {
            border-color: #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            animation: turnPulse 0.8s infinite;
        }
        .label-3d.dead {
            opacity: 0.3;
            text-decoration: line-through;
            color: #666;
        }
        @keyframes turnPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* Mic Status */
        .mic-status {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 10px;
            margin-top: 4px;
        }
        .mic-status.on {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            animation: micPulse 0.5s infinite;
        }
        .mic-status.off {
            background: rgba(255, 0, 0, 0.2);
            color: #ff0000;
        }
        @keyframes micPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px rgba(0,255,0,0.5); }
            50% { opacity: 0.7; box-shadow: 0 0 5px rgba(0,255,0,0.3); }
        }

        /* Chat */
        .chat-container {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 0, 0, 0.2);
            border-radius: 10px;
        }
        .chat-msg {
            animation: msgSlide 0.3s ease;
        }
        @keyframes msgSlide {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Blood Overlay */
        .blood-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle, transparent 20%, rgba(150, 0, 0, 0.9) 100%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 500;
        }

        /* Game Message */
        .game-msg {
            text-shadow: 
                0 0 20px currentColor,
                0 0 40px currentColor,
                0 0 80px currentColor;
        }

        /* Skull Animation */
        @keyframes skullFloat {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-10px) rotate(5deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); }
        ::-webkit-scrollbar-thumb { background: rgba(139, 0, 0, 0.6); border-radius: 4px; }
    </style>
</head>
<body>
    <!-- Background Effects -->
    <div class="bg-animated"></div>
    <div class="blood-rain" id="blood-rain"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div id="blood-overlay" class="blood-overlay"></div>

    <!-- ========== LOBBY SCREEN ========== -->
    <div id="lobby-screen" class="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="glass-card neon-border rounded-3xl w-full max-w-5xl overflow-hidden">
            
            <!-- Header -->
            <div class="p-8 border-b border-red-900/30 relative overflow-hidden">
                <div class="absolute inset-0 bg-gradient-to-r from-red-900/10 via-transparent to-red-900/10"></div>
                <div class="relative flex items-center justify-between">
                    <div class="flex items-center gap-6">
                        <div class="text-6xl" style="animation: skullFloat 3s ease infinite;">üíÄ</div>
                        <div>
                            <h1 class="font-horror text-5xl md:text-6xl text-red-600 tracking-wider" style="text-shadow: 0 0 30px rgba(255,0,0,0.8);">ROLETA RUSSA</h1>
                            <p class="text-red-500/60 mt-2 text-sm tracking-[0.5em] font-russo">MULTIPLAYER EXTREMO</p>
                        </div>
                    </div>
                    <div id="user-display" class="hidden text-right">
                        <p class="text-xs text-red-400/60 uppercase tracking-wider mb-1">Jogando como</p>
                        <div class="flex items-center gap-3 justify-end">
                            <span id="my-avatar-display" class="text-3xl"></span>
                            <span id="my-name-display" class="text-2xl font-bold text-white"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Content -->
            <div class="p-8">
                
                <!-- LOGIN VIEW -->
                <div id="login-view" class="flex flex-col items-center justify-center py-8">
                    <div class="w-40 h-40 mb-8 rounded-full bg-gradient-to-br from-red-900 to-black flex items-center justify-center relative">
                        <div class="absolute inset-0 rounded-full border-2 border-red-600/30 animate-ping"></div>
                        <div class="absolute inset-2 rounded-full border border-red-800/50"></div>
                        <i class="fas fa-skull text-6xl text-red-500"></i>
                    </div>
                    
                    <h2 class="text-2xl font-russo text-gray-300 mb-6 tracking-wider">ESCOLHA SEU AVATAR</h2>
                    
                    <!-- Avatar Selection -->
                    <div id="avatar-grid" class="flex gap-3 mb-8 flex-wrap justify-center max-w-md">
                        <div class="avatar-option selected" data-avatar="üíÄ">üíÄ</div>
                        <div class="avatar-option" data-avatar="üëπ">üëπ</div>
                        <div class="avatar-option" data-avatar="üéÉ">üéÉ</div>
                        <div class="avatar-option" data-avatar="üëª">üëª</div>
                        <div class="avatar-option" data-avatar="ü§°">ü§°</div>
                        <div class="avatar-option" data-avatar="üòà">üòà</div>
                        <div class="avatar-option" data-avatar="üßõ">üßõ</div>
                        <div class="avatar-option" data-avatar="üßü">üßü</div>
                        <div class="avatar-option" data-avatar="‚ò†Ô∏è">‚ò†Ô∏è</div>
                        <div class="avatar-option" data-avatar="üî™">üî™</div>
                    </div>
                    
                    <input type="text" id="nickname-input" 
                        class="input-dark w-80 px-6 py-4 rounded-xl text-center text-xl font-bold uppercase tracking-wider mb-6"
                        placeholder="SEU NOME" maxlength="12">
                    
                    <button id="btn-enter" class="btn-blood px-12 py-4 rounded-xl font-russo text-lg tracking-widest">
                        <i class="fas fa-door-open mr-3"></i> ENTRAR NO INFERNO
                    </button>
                    
                    <p class="text-xs text-red-900 mt-10 max-w-md text-center">
                        <i class="fas fa-exclamation-triangle mr-1"></i>
                        Conte√∫do +18. Simula√ß√£o apenas. Entretenimento.
                    </p>
                </div>

                <!-- ROOMS VIEW -->
                <div id="rooms-view" class="hidden">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                        
                        <!-- Rooms List -->
                        <div class="md:col-span-2">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="font-russo text-lg text-gray-400 tracking-wider flex items-center gap-3">
                                    <i class="fas fa-door-closed text-red-700"></i> SALAS ABERTAS
                                </h3>
                                <button id="btn-refresh" class="text-gray-600 hover:text-red-500 transition-colors text-sm">
                                    <i class="fas fa-sync-alt mr-1"></i> Atualizar
                                </button>
                            </div>
                            <div id="rooms-list" class="space-y-3 max-h-80 overflow-y-auto pr-2">
                                <div class="flex items-center justify-center py-16 text-gray-600">
                                    <div class="w-8 h-8 border-2 border-red-900 border-t-red-500 rounded-full animate-spin mr-4"></div>
                                    Procurando salas...
                                </div>
                            </div>
                        </div>

                        <!-- Create Room -->
                        <div class="glass-card rounded-xl p-6 border border-red-900/30">
                            <h3 class="font-russo text-lg text-gray-400 tracking-wider mb-6 flex items-center gap-3">
                                <i class="fas fa-plus-circle text-red-700"></i> CRIAR SALA
                            </h3>
                            <input type="text" id="room-name-input" 
                                class="input-dark w-full px-4 py-3 rounded-lg text-sm mb-4"
                                placeholder="Nome da sala..." maxlength="20">
                            <button id="btn-create" class="btn-blood w-full py-3 rounded-lg font-russo tracking-wider">
                                CRIAR SALA
                            </button>
                            <div class="mt-6 pt-6 border-t border-white/5 space-y-3">
                                <div class="flex items-center text-xs text-gray-500">
                                    <i class="fas fa-users w-6 text-red-900"></i> M√°ximo 6 jogadores
                                </div>
                                <div class="flex items-center text-xs text-gray-500">
                                    <i class="fas fa-microphone w-6 text-red-900"></i> Chat de voz
                                </div>
                                <div class="flex items-center text-xs text-gray-500">
                                    <i class="fas fa-comment w-6 text-red-900"></i> Chat de texto
                                </div>
                                <div class="flex items-center text-xs text-gray-500">
                                    <i class="fas fa-skull-crossbones w-6 text-red-900"></i> Gore extremo
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- ========== WAITING ROOM ========== -->
    <div id="waiting-room" class="fixed inset-0 z-40 hidden items-center justify-center p-4">
        <div class="glass-card neon-border rounded-3xl w-full max-w-4xl overflow-hidden">
            <div class="p-6 border-b border-red-900/30 flex items-center justify-between">
                <div>
                    <p class="text-xs text-red-400/60 uppercase tracking-wider">Sala</p>
                    <h2 id="current-room-name" class="text-3xl font-horror text-red-500"></h2>
                </div>
                <button id="btn-leave-room" class="btn-ghost px-4 py-2 rounded-lg text-sm">
                    <i class="fas fa-sign-out-alt mr-2"></i> Sair
                </button>
            </div>
            
            <div class="p-6">
                <h3 class="text-sm text-gray-500 uppercase tracking-wider mb-4">Jogadores na Mesa</h3>
                <div id="players-grid" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6"></div>
                
                <div id="host-controls" class="hidden border-t border-red-900/30 pt-6">
                    <button id="btn-start-match" class="btn-blood w-full py-4 rounded-xl font-horror text-2xl tracking-widest disabled:opacity-30 disabled:cursor-not-allowed" disabled>
                        <i class="fas fa-play mr-3"></i> INICIAR JOGO
                    </button>
                    <p class="text-center text-xs text-gray-600 mt-2">M√≠nimo 2 jogadores</p>
                </div>
                
                <div id="guest-waiting" class="text-center py-6">
                    <div class="w-8 h-8 border-2 border-red-900 border-t-red-500 rounded-full animate-spin mx-auto mb-4"></div>
                    <p class="text-gray-400">Aguardando o host iniciar...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- ========== GAME HUD ========== -->
    <div id="game-hud" class="fixed inset-0 z-30 hidden pointer-events-none">
        <div class="absolute inset-0 p-6 flex flex-col justify-between">
            
            <!-- Top Bar -->
            <div class="flex justify-between items-start pointer-events-auto">
                <button id="btn-leave-game" class="btn-ghost px-4 py-2 rounded-lg text-sm">
                    <i class="fas fa-arrow-left mr-2"></i> Sair
                </button>
                
                <div class="flex items-center gap-4">
                    <div id="round-info" class="text-right">
                        <p class="text-xs text-gray-500">RODADA</p>
                        <p id="round-num" class="text-2xl font-horror text-red-500">1</p>
                    </div>
                    <button id="btn-mic" class="w-14 h-14 rounded-full btn-ghost flex items-center justify-center text-2xl border-2">
                        <i class="fas fa-microphone-slash"></i>
                    </button>
                </div>
            </div>

            <!-- Center Message -->
            <div id="game-message" class="text-center opacity-0 transition-all duration-500">
                <h2 id="msg-text" class="font-horror text-7xl text-red-600 game-msg"></h2>
                <p id="msg-sub" class="text-xl text-gray-400 mt-4"></p>
            </div>

            <!-- Bottom -->
            <div class="flex justify-center items-end pb-10">
                <button id="btn-trigger" class="hidden pointer-events-auto btn-blood px-20 py-8 rounded-2xl font-horror text-5xl tracking-widest transform hover:scale-105 transition-transform">
                    <i class="fas fa-hand-pointer mr-4"></i> PUXAR GATILHO
                </button>
                
                <div id="watching-msg" class="hidden text-center">
                    <p class="text-gray-500 text-lg"><i class="fas fa-eye mr-2"></i> Aguardando...</p>
                </div>
            </div>
        </div>

        <!-- Chat Box -->
        <div id="chat-box" class="absolute bottom-6 left-6 w-80 pointer-events-auto">
            <div class="chat-container overflow-hidden">
                <div class="bg-black/50 px-3 py-2 border-b border-red-900/30">
                    <span class="text-xs text-gray-500 uppercase tracking-wider"><i class="fas fa-comment mr-2"></i>Chat</span>
                </div>
                <div id="chat-messages" class="h-32 overflow-y-auto p-3 space-y-2 text-sm"></div>
                <div class="border-t border-red-900/30 p-2 flex gap-2">
                    <input type="text" id="chat-input" class="input-dark flex-1 px-3 py-2 rounded text-sm" placeholder="Digite..." maxlength="100">
                    <button id="btn-send-chat" class="btn-blood px-4 py-2 rounded text-sm">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 3D Labels Container -->
    <div id="labels-3d" class="fixed inset-0 pointer-events-none z-20"></div>

    <!-- 3D Canvas -->
    <div id="canvas-container" class="fixed inset-0 z-0"></div>

    <!-- ========== SCRIPTS ========== -->
    <script type="module">
        // Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, push, get, update, remove, onValue, onDisconnect } 
            from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCfdgkO3WzaxXT-djAA6MsLC2m26c9optU",
            authDomain: "slider-io.firebaseapp.com",
            databaseURL: "https://slider-io-default-rtdb.firebaseio.com",
            projectId: "slider-io",
            storageBucket: "slider-io.firebasestorage.app",
            messagingSenderId: "395647141464",
            appId: "1:395647141464:web:251cc58a3e0e90ca262c2d"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // ====== STATE ======
        let myId = localStorage.getItem('rr_id') || 'u_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('rr_id', myId);
        let myName = "";
        let myAvatar = "üíÄ";
        let currentRoom = null;
        let isHost = false;
        let mySlot = -1;
        let gameData = null;
        let roundNum = 1;

        // 3D
        let scene, camera, renderer, clock;
        let playerMeshes = {};
        let magnumGun, cylinderMesh;
        let particles = [];
        let audioCtx;

        // Mic
        let micStream = null;
        let isMuted = true;

        // DOM
        const $lobby = document.getElementById('lobby-screen');
        const $loginView = document.getElementById('login-view');
        const $roomsView = document.getElementById('rooms-view');
        const $roomsList = document.getElementById('rooms-list');
        const $waitingRoom = document.getElementById('waiting-room');
        const $playersGrid = document.getElementById('players-grid');
        const $gameHud = document.getElementById('game-hud');
        const $labels3d = document.getElementById('labels-3d');
        const $msgText = document.getElementById('msg-text');
        const $msgSub = document.getElementById('msg-sub');
        const $gameMessage = document.getElementById('game-message');
        const $bloodOverlay = document.getElementById('blood-overlay');
        const $chatMessages = document.getElementById('chat-messages');
        const $chatInput = document.getElementById('chat-input');

        // Create blood rain
        const bloodRain = document.getElementById('blood-rain');
        for(let i = 0; i < 50; i++) {
            const drop = document.createElement('div');
            drop.className = 'blood-drop';
            drop.style.left = Math.random() * 100 + '%';
            drop.style.animationDuration = (2 + Math.random() * 3) + 's';
            drop.style.animationDelay = Math.random() * 5 + 's';
            bloodRain.appendChild(drop);
        }

        // Avatar selection
        document.querySelectorAll('.avatar-option').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('.avatar-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                myAvatar = opt.dataset.avatar;
            });
        });

        // ====== LOBBY ======

        document.getElementById('btn-enter').onclick = () => {
            const name = document.getElementById('nickname-input').value.trim();
            if (!name) return alert("Digite seu nome!");
            myName = name.toUpperCase();
            document.getElementById('my-name-display').textContent = myName;
            document.getElementById('my-avatar-display').textContent = myAvatar;
            document.getElementById('user-display').classList.remove('hidden');
            $loginView.classList.add('hidden');
            $roomsView.classList.remove('hidden');
            listenToRooms();
        };

        document.getElementById('nickname-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('btn-enter').click();
        });

        document.getElementById('btn-create').onclick = async () => {
            const name = document.getElementById('room-name-input').value.trim() || `Sala de ${myName}`;
            const roomRef = push(ref(db, 'rooms'));
            await set(roomRef, {
                name: name,
                hostId: myId,
                hostName: myName,
                status: 'waiting',
                createdAt: Date.now()
            });
            joinRoom(roomRef.key);
        };

        document.getElementById('btn-refresh').onclick = listenToRooms;

        function listenToRooms() {
            onValue(ref(db, 'rooms'), (snap) => {
                $roomsList.innerHTML = '';
                const rooms = snap.val();
                if (!rooms) {
                    $roomsList.innerHTML = '<p class="text-center text-gray-600 py-12">Nenhuma sala. Crie uma!</p>';
                    return;
                }
                
                Object.entries(rooms).forEach(([id, room]) => {
                    const count = room.players ? Object.keys(room.players).length : 0;
                    const isFull = count >= 6;
                    const isPlaying = room.status === 'playing';
                    
                    const div = document.createElement('div');
                    div.className = 'room-card rounded-xl p-4 flex items-center justify-between';
                    div.innerHTML = `
                        <div class="flex items-center gap-4">
                            <div class="w-14 h-14 rounded-full bg-gradient-to-br from-red-900 to-black flex items-center justify-center text-2xl">
                                üíÄ
                            </div>
                            <div>
                                <p class="font-bold text-white text-lg">${room.name}</p>
                                <p class="text-xs text-gray-500">Host: ${room.hostName}</p>
                            </div>
                        </div>
                        <div class="flex items-center gap-4">
                            ${isPlaying ? '<span class="text-xs text-yellow-500 bg-yellow-900/30 px-2 py-1 rounded"><i class="fas fa-gamepad mr-1"></i>Em jogo</span>' : ''}
                            <span class="text-xl font-bold ${isFull ? 'text-red-500' : 'text-green-500'}">${count}/6</span>
                            <i class="fas fa-chevron-right text-gray-700"></i>
                        </div>
                    `;
                    if (!isFull && !isPlaying) {
                        div.onclick = () => joinRoom(id);
                    } else {
                        div.style.opacity = '0.4';
                        div.style.cursor = 'not-allowed';
                    }
                    $roomsList.appendChild(div);
                });
            }, { onlyOnce: true });
        }

        async function joinRoom(roomId) {
            const snap = await get(ref(db, `rooms/${roomId}`));
            const room = snap.val();
            if (!room) return;
            
            const players = room.players || {};
            const count = Object.keys(players).length;
            if (count >= 6) return alert("Sala cheia!");

            const takenSlots = Object.values(players).map(p => p.slot);
            mySlot = 0;
            while (takenSlots.includes(mySlot)) mySlot++;

            currentRoom = roomId;
            isHost = room.hostId === myId;

            const playerRef = ref(db, `rooms/${roomId}/players/${myId}`);
            await set(playerRef, {
                name: myName,
                avatar: myAvatar,
                slot: mySlot,
                isDead: false,
                micOn: false
            });
            onDisconnect(playerRef).remove();

            $lobby.classList.add('hidden');
            $waitingRoom.style.display = 'flex';
            document.getElementById('current-room-name').textContent = room.name;

            if (isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('guest-waiting').classList.add('hidden');
            }

            // Generate slots
            $playersGrid.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                slot.id = `slot-${i}`;
                slot.className = 'player-slot rounded-xl p-4 text-center h-32 flex flex-col items-center justify-center';
                slot.innerHTML = `<i class="fas fa-user-slash text-4xl text-gray-800"></i><p class="text-xs text-gray-700 mt-2">Vazio</p>`;
                $playersGrid.appendChild(slot);
            }

            // Listen to room
            onValue(ref(db, `rooms/${roomId}`), (snap) => {
                const data = snap.val();
                if (!data) {
                    leaveRoom();
                    return;
                }
                
                gameData = data;
                updateWaitingRoom(data);
                
                if (data.status === 'playing') {
                    startGame(data);
                }
                
                if (data.status === 'restarting') {
                    handleRestart();
                }
            });

            // Chat
            onValue(ref(db, `rooms/${roomId}/chat`), (snap) => {
                const messages = snap.val();
                if (!messages) return;
                $chatMessages.innerHTML = '';
                Object.values(messages).slice(-50).forEach(msg => {
                    const div = document.createElement('div');
                    div.className = 'chat-msg';
                    div.innerHTML = `<span class="text-red-500 font-bold">${msg.avatar} ${msg.name}:</span> <span class="text-gray-300">${msg.text}</span>`;
                    $chatMessages.appendChild(div);
                });
                $chatMessages.scrollTop = $chatMessages.scrollHeight;
            });
        }

        function updateWaitingRoom(room) {
            const players = room.players || {};
            const count = Object.keys(players).length;

            for (let i = 0; i < 6; i++) {
                const slot = document.getElementById(`slot-${i}`);
                if (!slot) continue;
                slot.className = 'player-slot rounded-xl p-4 text-center h-32 flex flex-col items-center justify-center';
                slot.innerHTML = `<i class="fas fa-user-slash text-4xl text-gray-800"></i><p class="text-xs text-gray-700 mt-2">Vazio</p>`;
            }

            Object.entries(players).forEach(([pid, p]) => {
                const slot = document.getElementById(`slot-${p.slot}`);
                if (!slot) return;
                slot.classList.add('occupied');
                if (pid === myId) slot.classList.add('is-me');
                slot.innerHTML = `
                    <div class="text-4xl mb-2">${p.avatar || 'üíÄ'}</div>
                    <p class="text-sm font-bold ${pid === myId ? 'text-red-400' : 'text-white'}">${p.name}</p>
                    ${pid === room.hostId ? '<span class="text-xs text-yellow-500"><i class="fas fa-crown"></i></span>' : ''}
                `;
            });

            const startBtn = document.getElementById('btn-start-match');
            if (startBtn) startBtn.disabled = count < 2;
        }

        document.getElementById('btn-leave-room').onclick = leaveRoom;
        document.getElementById('btn-leave-game').onclick = leaveRoom;

        function leaveRoom() {
            if (currentRoom) {
                remove(ref(db, `rooms/${currentRoom}/players/${myId}`));
                get(ref(db, `rooms/${currentRoom}/players`)).then((snap) => {
                    if (!snap.exists()) {
                        remove(ref(db, `rooms/${currentRoom}`));
                    }
                });
            }
            
            if (micStream) {
                micStream.getTracks().forEach(t => t.stop());
                micStream = null;
            }
            
            currentRoom = null;
            mySlot = -1;
            gameData = null;
            roundNum = 1;
            
            $waitingRoom.style.display = 'none';
            $gameHud.classList.add('hidden');
            $lobby.classList.remove('hidden');
            
            Object.values(playerMeshes).forEach(m => scene?.remove(m));
            playerMeshes = {};
            $labels3d.innerHTML = '';
        }

        document.getElementById('btn-start-match').onclick = async () => {
            const bullet = Math.floor(Math.random() * 6);
            const snap = await get(ref(db, `rooms/${currentRoom}/players`));
            const players = snap.val();
            const slots = Object.values(players).map(p => p.slot).sort((a, b) => a - b);
            
            await update(ref(db, `rooms/${currentRoom}`), {
                status: 'playing',
                bulletPos: bullet,
                chamber: 0,
                currentTurnSlot: slots[0],
                round: 1,
                lastAction: null
            });
        };

        // ====== GAME ======

        function startGame(room) {
            $waitingRoom.style.display = 'none';
            $gameHud.classList.remove('hidden');
            
            if (!scene) init3D();
            setupGameLoop();
            showMessage("QUE O JOGO COMECE", "Boa sorte... üíÄ", 2500);
        }

        function setupGameLoop() {
            onValue(ref(db, `rooms/${currentRoom}`), (snap) => {
                const room = snap.val();
                if (!room) return;
                
                gameData = room;
                
                if (room.status === 'playing') {
                    updateGameState(room);
                }
                
                // Handle last action for sync
                if (room.lastAction) {
                    handleAction(room.lastAction);
                }
            });
        }

        let lastActionTime = 0;
        
        function handleAction(action) {
            if (action.time <= lastActionTime) return;
            lastActionTime = action.time;
            
            if (action.type === 'bang') {
                handleBangSync(action.slot, action.name);
            } else if (action.type === 'click') {
                playSound('click');
                if (cylinderMesh) cylinderMesh.rotation.z += Math.PI / 3;
            }
        }

        function handleBangSync(slot, name) {
            playSound('bang');
            
            const mesh = Object.values(playerMeshes).find(m => m.userData.slot === slot);
            if (mesh) {
                // Gore explosion
                const headPos = mesh.position.clone();
                headPos.y += 8;
                createMassiveGore(headPos);
                
                // Hide head
                if (mesh.userData.headGroup) {
                    mesh.userData.headGroup.visible = false;
                }
                
                // Fall animation
                let fall = 0;
                const fallInterval = setInterval(() => {
                    fall += 0.12;
                    mesh.rotation.x = -Math.min(fall, 1.5);
                    mesh.position.y = -5 - fall * 2;
                    if (fall >= 1.5) clearInterval(fallInterval);
                }, 16);
            }
            
            // Gun recoil
            if (magnumGun) {
                magnumGun.rotation.x = -0.5;
                setTimeout(() => magnumGun.rotation.x = 0, 200);
            }
            
            // Blood overlay if it's me
            if (slot === mySlot) {
                $bloodOverlay.style.opacity = 1;
                setTimeout(() => $bloodOverlay.style.opacity = 0.5, 500);
            }
        }

        function updateGameState(room) {
            const players = room.players || {};
            const alivePlayers = Object.entries(players).filter(([_, p]) => !p.isDead);
            
            document.getElementById('round-num').textContent = room.round || 1;
            
            // Check winner
            if (alivePlayers.length === 1) {
                const [winnerId, winner] = alivePlayers[0];
                const isMe = winnerId === myId;
                showMessage(
                    isMe ? "VOC√ä VENCEU!" : `${winner.name} VENCEU!`, 
                    isMe ? "Sobrevivente! üèÜ" : "√önico sobrevivente...", 
                    5000
                );
                document.getElementById('btn-trigger').classList.add('hidden');
                
                // Restart after delay (host triggers)
                if (isHost) {
                    setTimeout(() => {
                        update(ref(db, `rooms/${currentRoom}`), { status: 'restarting' });
                    }, 5000);
                }
                return;
            }
            
            if (alivePlayers.length === 0) {
                showMessage("TODOS MORTOS", "Fim de jogo", 5000);
                if (isHost) {
                    setTimeout(() => {
                        update(ref(db, `rooms/${currentRoom}`), { status: 'restarting' });
                    }, 5000);
                }
                return;
            }

            // Update 3D
            update3DPlayers(players, room.currentTurnSlot);
            rotateGunToSlot(room.currentTurnSlot);

            // Check my turn
            const me = players[myId];
            const isMyTurn = me && !me.isDead && me.slot === room.currentTurnSlot;
            
            if (isMyTurn) {
                document.getElementById('btn-trigger').classList.remove('hidden');
                document.getElementById('watching-msg').classList.add('hidden');
                showMessage("SUA VEZ", "Puxe o gatilho...", 2000);
            } else {
                document.getElementById('btn-trigger').classList.add('hidden');
                if (!me || me.isDead) {
                    document.getElementById('watching-msg').classList.remove('hidden');
                    document.getElementById('watching-msg').innerHTML = '<p class="text-gray-500 text-lg"><i class="fas fa-skull mr-2"></i> Voc√™ est√° morto. Observando...</p>';
                } else {
                    document.getElementById('watching-msg').classList.remove('hidden');
                    document.getElementById('watching-msg').innerHTML = '<p class="text-gray-500 text-lg"><i class="fas fa-hourglass-half mr-2"></i> Aguardando turno...</p>';
                }
            }
        }

        async function handleRestart() {
            showMessage("NOVA RODADA", "Reiniciando...", 2000);
            
            $bloodOverlay.style.opacity = 0;
            
            // Reset player states
            if (isHost) {
                const snap = await get(ref(db, `rooms/${currentRoom}/players`));
                const players = snap.val();
                const updates = {};
                const slots = [];
                
                Object.entries(players).forEach(([pid, p]) => {
                    updates[`players/${pid}/isDead`] = false;
                    slots.push(p.slot);
                });
                
                slots.sort((a, b) => a - b);
                
                updates.status = 'playing';
                updates.bulletPos = Math.floor(Math.random() * 6);
                updates.chamber = 0;
                updates.currentTurnSlot = slots[0];
                updates.round = (gameData?.round || 1) + 1;
                updates.lastAction = null;
                
                await update(ref(db, `rooms/${currentRoom}`), updates);
            }
            
            // Reset 3D meshes
            Object.values(playerMeshes).forEach(mesh => {
                mesh.rotation.x = 0;
                mesh.position.y = -5;
                if (mesh.userData.headGroup) {
                    mesh.userData.headGroup.visible = true;
                }
            });
        }

        document.getElementById('btn-trigger').onclick = async () => {
            const btn = document.getElementById('btn-trigger');
            btn.classList.add('hidden');
            btn.disabled = true;
            
            const snap = await get(ref(db, `rooms/${currentRoom}`));
            const room = snap.val();
            const players = room.players || {};
            
            const isBang = room.chamber === room.bulletPos;
            
            if (cylinderMesh) cylinderMesh.rotation.z += Math.PI / 3;
            
            if (isBang) {
                // I die
                await update(ref(db, `rooms/${currentRoom}/players/${myId}`), { isDead: true });
                
                // Find next alive player
                const alivePlayers = Object.entries(players)
                    .filter(([pid, p]) => pid !== myId && !p.isDead)
                    .sort((a, b) => a[1].slot - b[1].slot);
                
                let nextSlot = room.currentTurnSlot;
                if (alivePlayers.length > 0) {
                    const next = alivePlayers.find(([_, p]) => p.slot > room.currentTurnSlot) || alivePlayers[0];
                    nextSlot = next[1].slot;
                }
                
                await update(ref(db, `rooms/${currentRoom}`), {
                    chamber: (room.chamber + 1) % 6,
                    currentTurnSlot: nextSlot,
                    lastAction: { type: 'bang', slot: mySlot, name: myName, time: Date.now() }
                });
                
                showMessage("VOC√ä MORREU", "üíÄüíÄüíÄ", 3000);
                
            } else {
                // Survived
                const alivePlayers = Object.entries(players)
                    .filter(([_, p]) => !p.isDead)
                    .sort((a, b) => a[1].slot - b[1].slot);
                
                const next = alivePlayers.find(([_, p]) => p.slot > room.currentTurnSlot) || alivePlayers[0];
                
                await update(ref(db, `rooms/${currentRoom}`), {
                    chamber: (room.chamber + 1) % 6,
                    currentTurnSlot: next[1].slot,
                    lastAction: { type: 'click', slot: mySlot, time: Date.now() }
                });
                
                showMessage("CLICK", "Voc√™ sobreviveu...", 1500);
            }
            
            btn.disabled = false;
        };

        function showMessage(title, sub, duration) {
            $msgText.textContent = title;
            $msgSub.textContent = sub;
            $gameMessage.style.opacity = 1;
            setTimeout(() => $gameMessage.style.opacity = 0, duration);
        }

        // ====== CHAT ======

        document.getElementById('btn-send-chat').onclick = sendChat;
        $chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendChat();
        });

        function sendChat() {
            const text = $chatInput.value.trim();
            if (!text || !currentRoom) return;
            
            push(ref(db, `rooms/${currentRoom}/chat`), {
                name: myName,
                avatar: myAvatar,
                text: text,
                time: Date.now()
            });
            
            $chatInput.value = '';
        }

        // ====== 3D ======

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0000, 0.018);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0x1a0000, 0.5);
            scene.add(ambient);
            
            const spot = new THREE.SpotLight(0xffeedd, 1.5);
            spot.position.set(0, 40, 0);
            spot.angle = Math.PI / 3;
            spot.penumbra = 0.8;
            spot.castShadow = true;
            scene.add(spot);
            
            const redLight = new THREE.PointLight(0x660000, 1, 50);
            redLight.position.set(-20, 10, -20);
            scene.add(redLight);

            const redLight2 = new THREE.PointLight(0x440000, 0.8, 50);
            redLight2.position.set(20, 10, 20);
            scene.add(redLight2);
            
            // Table
            const tableGeo = new THREE.CylinderGeometry(15, 15, 1.5, 64);
            const tableMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a0a05, 
                roughness: 0.6,
                metalness: 0.1
            });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.y = -1;
            table.receiveShadow = true;
            scene.add(table);
            
            // Table felt
            const feltGeo = new THREE.CircleGeometry(14, 64);
            feltGeo.rotateX(-Math.PI / 2);
            const feltMat = new THREE.MeshStandardMaterial({ color: 0x0a1a0a, roughness: 1 });
            const felt = new THREE.Mesh(feltGeo, feltMat);
            felt.position.y = -0.2;
            scene.add(felt);
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(300, 300);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x050202, roughness: 1 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -15;
            floor.receiveShadow = true;
            scene.add(floor);
            
            createMagnumRevolver();
            
            clock = new THREE.Clock();
            window.addEventListener('resize', onResize);
            animate();
        }

        function createMagnumRevolver() {
            magnumGun = new THREE.Group();
            
            const metalDark = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.95, roughness: 0.1 });
            const metalShiny = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.98, roughness: 0.05 });
            const wood = new THREE.MeshStandardMaterial({ color: 0x4a2510, roughness: 0.5, metalness: 0 });
            
            // Main barrel (long magnum style)
            const barrelOuter = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 8, 32), metalShiny);
            barrelOuter.rotation.x = Math.PI / 2;
            barrelOuter.position.z = 4;
            barrelOuter.castShadow = true;
            magnumGun.add(barrelOuter);
            
            // Barrel hole
            const barrelHole = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.5, 16), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            barrelHole.rotation.x = Math.PI / 2;
            barrelHole.position.z = 8;
            magnumGun.add(barrelHole);
            
            // Barrel rib (top sight rail)
            const rib = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 7), metalDark);
            rib.position.set(0, 0.6, 3.5);
            magnumGun.add(rib);
            
            // Front sight
            const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.3, 0.3), metalShiny);
            frontSight.position.set(0, 0.7, 7.5);
            magnumGun.add(frontSight);
            
            // Cylinder housing
            const housing = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 3), metalDark);
            housing.position.set(0, 0, 0);
            magnumGun.add(housing);
            
            // Cylinder
            cylinderMesh = new THREE.Group();
            
            const cylBody = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 2.5, 32), metalShiny);
            cylBody.rotation.x = Math.PI / 2;
            cylBody.castShadow = true;
            cylinderMesh.add(cylBody);
            
            // Cylinder flutes and chambers
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                
                // Chamber hole
                const chamber = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.35, 2.6, 12), 
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                chamber.rotation.x = Math.PI / 2;
                chamber.position.set(Math.cos(angle) * 0.75, Math.sin(angle) * 0.75, 0);
                cylinderMesh.add(chamber);
                
                // Flute (groove)
                const flute = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.5, 2.3),
                    metalDark
                );
                flute.position.set(Math.cos(angle + 0.5) * 1.2, Math.sin(angle + 0.5) * 1.2, 0);
                flute.rotation.z = angle + 0.5;
                cylinderMesh.add(flute);
            }
            
            cylinderMesh.position.z = 0;
            magnumGun.add(cylinderMesh);
            
            // Frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 5), metalDark);
            frame.position.set(0, -0.5, -2);
            frame.castShadow = true;
            magnumGun.add(frame);
            
            // Trigger guard
            const guardCurve = new THREE.TorusGeometry(0.8, 0.1, 8, 16, Math.PI);
            const guard = new THREE.Mesh(guardCurve, metalDark);
            guard.position.set(0, -1.8, -1.5);
            guard.rotation.z = Math.PI;
            magnumGun.add(guard);
            
            // Trigger
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.3), metalShiny);
            trigger.position.set(0, -1.5, -1.5);
            trigger.rotation.x = -0.3;
            magnumGun.add(trigger);
            
            // Hammer
            const hammer = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.2, 0.6), metalShiny);
            hammer.position.set(0, 1.2, -3.5);
            hammer.rotation.x = -0.4;
            magnumGun.add(hammer);
            
            // Grip
            const grip = new THREE.Mesh(new THREE.BoxGeometry(1.6, 4, 2.2), wood);
            grip.position.set(0, -3.5, -4);
            grip.rotation.x = 0.3;
            grip.castShadow = true;
            magnumGun.add(grip);
            
            // Grip checkering pattern
            for (let i = 0; i < 8; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.3, 1.8),
                    new THREE.MeshStandardMaterial({ color: 0x2a1508 })
                );
                line.position.set(0.85, -2.5 - i * 0.35, -4);
                line.rotation.x = 0.3;
                magnumGun.add(line);
                
                const line2 = line.clone();
                line2.position.x = -0.85;
                magnumGun.add(line2);
            }
            
            magnumGun.position.y = 1.5;
            magnumGun.scale.set(1.2, 1.2, 1.2);
            scene.add(magnumGun);
        }

        function createPlayerMesh(id, data) {
            const group = new THREE.Group();
            const angle = data.slot * (Math.PI * 2 / 6) - Math.PI / 2;
            const radius = 18;
            
            group.position.set(
                Math.cos(angle) * radius,
                -5,
                Math.sin(angle) * radius
            );
            group.lookAt(0, -3, 0);
            
            const colors = [0x8b0000, 0x006400, 0x00008b, 0x8b8b00, 0x008b8b, 0x4b0082];
            const skinTone = 0xe8beac;
            
            const clothMat = new THREE.MeshStandardMaterial({ color: colors[data.slot] || 0x333333, roughness: 0.6 });
            const skinMat = new THREE.MeshStandardMaterial({ color: skinTone, roughness: 0.4 });
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x1a1209, roughness: 0.8 });
            
            // Body
            const torso = new THREE.Mesh(new THREE.BoxGeometry(5, 7, 3), clothMat);
            torso.position.y = 3.5;
            torso.castShadow = true;
            group.add(torso);
            
            // Shoulders
            const shoulderL = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), clothMat);
            shoulderL.position.set(-3, 5.5, 0);
            group.add(shoulderL);
            
            const shoulderR = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), clothMat);
            shoulderR.position.set(3, 5.5, 0);
            group.add(shoulderR);
            
            // Arms
            const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.5, 5, 12), clothMat);
            armL.position.set(-3.5, 2, 2.5);
            armL.rotation.x = -1;
            armL.rotation.z = 0.2;
            group.add(armL);
            
            const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.5, 5, 12), clothMat);
            armR.position.set(3.5, 2, 2.5);
            armR.rotation.x = -1;
            armR.rotation.z = -0.2;
            group.add(armR);
            
            // Hands
            const handL = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), skinMat);
            handL.position.set(-3, 0, 5);
            group.add(handL);
            
            const handR = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), skinMat);
            handR.position.set(3, 0, 5);
            group.add(handR);
            
            // Neck
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.8, 1.5, 12), skinMat);
            neck.position.y = 7.5;
            group.add(neck);
            
            // Head Group
            const headGroup = new THREE.Group();
            headGroup.position.y = 9;
            group.add(headGroup);
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.8, 24, 24), skinMat);
            head.scale.set(1, 1.15, 1);
            head.castShadow = true;
            headGroup.add(head);
            
            // Eyes
            const eyeWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyePupil = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), eyeWhite);
            eyeL.position.set(-0.6, 0.3, 1.6);
            headGroup.add(eyeL);
            
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), eyePupil);
            pupilL.position.set(-0.6, 0.3, 1.78);
            headGroup.add(pupilL);
            
            const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), eyeWhite);
            eyeR.position.set(0.6, 0.3, 1.6);
            headGroup.add(eyeR);
            
            const pupilR = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), eyePupil);
            pupilR.position.set(0.6, 0.3, 1.78);
            headGroup.add(pupilR);
            
            // Eyebrows
            const browL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.15), hairMat);
            browL.position.set(-0.6, 0.7, 1.65);
            browL.rotation.z = 0.15;
            headGroup.add(browL);
            
            const browR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.15), hairMat);
            browR.position.set(0.6, 0.7, 1.65);
            browR.rotation.z = -0.15;
            headGroup.add(browR);
            
            // Nose
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), skinMat);
            nose.position.set(0, 0, 1.8);
            nose.rotation.x = Math.PI / 2;
            headGroup.add(nose);
            
            // Mouth
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.12, 0.1), new THREE.MeshBasicMaterial({ color: 0x8b4040 }));
            mouth.position.set(0, -0.6, 1.7);
            headGroup.add(mouth);
            
            // Hair
            const hair = new THREE.Mesh(
                new THREE.SphereGeometry(1.9, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2.2),
                hairMat
            );
            hair.position.y = 0.3;
            hair.rotation.x = -0.15;
            headGroup.add(hair);
            
            // Ears
            const earL = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), skinMat);
            earL.scale.set(0.5, 1, 0.6);
            earL.position.set(-1.7, 0, 0);
            headGroup.add(earL);
            
            const earR = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), skinMat);
            earR.scale.set(0.5, 1, 0.6);
            earR.position.set(1.7, 0, 0);
            headGroup.add(earR);
            
            group.userData = { 
                id, 
                slot: data.slot, 
                headGroup, 
                isDead: data.isDead,
                offset: Math.random() * 100
            };
            
            if (data.isDead) {
                headGroup.visible = false;
                group.rotation.x = -1.5;
            }
            
            scene.add(group);
            playerMeshes[id] = group;
            
            createLabel(id, data);
            
            return group;
        }

        function createLabel(id, data) {
            const label = document.createElement('div');
            label.id = `label-${id}`;
            label.className = 'label-3d';
            
            let micHtml = '';
            if (id === myId) {
                micHtml = `<div class="mic-status ${isMuted ? 'off' : 'on'}">
                    <i class="fas ${isMuted ? 'fa-microphone-slash' : 'fa-microphone'}"></i>
                    <span>${isMuted ? 'MUDO' : 'AO VIVO'}</span>
                </div>`;
            }
            
            label.innerHTML = `
                <span class="avatar-emoji">${data.avatar || 'üíÄ'}</span>
                <span>${data.name}${id === myId ? ' (voc√™)' : ''}</span>
                ${micHtml}
            `;
            
            $labels3d.appendChild(label);
        }

        function update3DPlayers(players, currentTurnSlot) {
            // Remove old
            Object.keys(playerMeshes).forEach(id => {
                if (!players[id]) {
                    scene.remove(playerMeshes[id]);
                    delete playerMeshes[id];
                    const label = document.getElementById(`label-${id}`);
                    if (label) label.remove();
                }
            });
            
            // Add/update
            Object.entries(players).forEach(([id, data]) => {
                if (!playerMeshes[id]) {
                    createPlayerMesh(id, data);
                }
                
                const mesh = playerMeshes[id];
                const label = document.getElementById(`label-${id}`);
                
                if (label) {
                    label.classList.toggle('current-turn', data.slot === currentTurnSlot && !data.isDead);
                    label.classList.toggle('dead', data.isDead);
                    
                    // Update mic status for me
                    if (id === myId) {
                        const micStatus = label.querySelector('.mic-status');
                        if (micStatus) {
                            micStatus.className = `mic-status ${isMuted ? 'off' : 'on'}`;
                            micStatus.innerHTML = `
                                <i class="fas ${isMuted ? 'fa-microphone-slash' : 'fa-microphone'}"></i>
                                <span>${isMuted ? 'MUDO' : 'AO VIVO'}</span>
                            `;
                        }
                    }
                }
                
                if (data.isDead && mesh.userData.headGroup?.visible) {
                    mesh.userData.headGroup.visible = false;
                }
            });
            
            // Camera position based on my slot
            const myPlayer = players[myId];
            if (myPlayer) {
                const angle = myPlayer.slot * (Math.PI * 2 / 6) - Math.PI / 2;
                const camX = Math.cos(angle) * 32;
                const camZ = Math.sin(angle) * 32;
                camera.position.lerp(new THREE.Vector3(camX, 16, camZ), 0.1);
                camera.lookAt(0, 0, 0);
            }
        }

        function rotateGunToSlot(slot) {
            if (!magnumGun) return;
            const angle = slot * (Math.PI * 2 / 6) - Math.PI / 2;
            
            // Fast spin
            const targetY = -angle;
            let spins = 0;
            const maxSpins = 20;
            
            const spinInterval = setInterval(() => {
                magnumGun.rotation.y += 0.5;
                spins++;
                if (spins >= maxSpins) {
                    clearInterval(spinInterval);
                    magnumGun.rotation.y = targetY;
                }
            }, 16);
        }

        function createMassiveGore(pos) {
            // Blood particles
            for (let i = 0; i < 300; i++) {
                const geo = new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(0, 1, 0.2 + Math.random() * 0.3)
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(pos);
                scene.add(particle);
                
                particles.push({
                    mesh: particle,
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5) * 25,
                        Math.random() * 20,
                        (Math.random() - 0.5) * 25
                    ),
                    age: 0,
                    maxAge: 2 + Math.random() * 2
                });
            }
            
            // Gore chunks
            for (let i = 0; i < 20; i++) {
                const size = Math.random() * 0.8 + 0.3;
                const geo = new THREE.BoxGeometry(size, size, size);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(0, 0.8, 0.15 + Math.random() * 0.1),
                    roughness: 0.3
                });
                const chunk = new THREE.Mesh(geo, mat);
                chunk.position.copy(pos);
                scene.add(chunk);
                
                particles.push({
                    mesh: chunk,
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5) * 18,
                        Math.random() * 15,
                        (Math.random() - 0.5) * 18
                    ),
                    angVel: new THREE.Vector3(
                        Math.random() * 10,
                        Math.random() * 10,
                        Math.random() * 10
                    ),
                    age: 0,
                    maxAge: 4 + Math.random() * 3,
                    isChunk: true
                });
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!scene || !camera || !renderer) return;
            
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.age += dt;
                
                p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                p.vel.y -= 30 * dt; // Gravity
                
                if (p.isChunk && p.angVel) {
                    p.mesh.rotation.x += p.angVel.x * dt;
                    p.mesh.rotation.y += p.angVel.y * dt;
                    p.mesh.rotation.z += p.angVel.z * dt;
                }
                
                // Fade out
                if (p.age > p.maxAge * 0.7) {
                    p.mesh.material.opacity = 1 - (p.age - p.maxAge * 0.7) / (p.maxAge * 0.3);
                    p.mesh.material.transparent = true;
                }
                
                if (p.age > p.maxAge) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
            
            // Animate players
            Object.values(playerMeshes).forEach(mesh => {
                if (mesh.userData.isDead) return;
                
                const offset = mesh.userData.offset;
                
                // Breathing
                mesh.position.y = -5 + Math.sin(time * 2 + offset) * 0.08;
                
                // Head movement
                if (mesh.userData.headGroup) {
                    mesh.userData.headGroup.rotation.y = Math.sin(time * 0.4 + offset) * 0.12;
                    mesh.userData.headGroup.rotation.x = Math.sin(time * 0.25 + offset) * 0.06;
                }
            });
            
            // Update labels
            Object.entries(playerMeshes).forEach(([id, mesh]) => {
                const label = document.getElementById(`label-${id}`);
                if (!label) return;
                
                const pos = mesh.position.clone();
                pos.y += 14;
                pos.project(camera);
                
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
                label.style.display = pos.z > 1 ? 'none' : 'flex';
            });
            
            renderer.render(scene, camera);
        }

        // ====== AUDIO ======

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioCtx) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const now = audioCtx.currentTime;
            
            if (type === 'click') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(1500, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.6, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'bang') {
                // Deep boom
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);
                gain.gain.setValueAtTime(2.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                osc.start(now);
                osc.stop(now + 0.8);
                
                // Noise
                const bufferSize = audioCtx.sampleRate * 0.6;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 1.2);
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(1.5, now);
                noise.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noise.start(now);
            }
        }

        // ====== MIC ======

        document.getElementById('btn-mic').onclick = async () => {
            if (!micStream) {
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    micStream.getAudioTracks()[0].enabled = false;
                } catch (e) {
                    console.error('Mic error:', e);
                    alert('N√£o foi poss√≠vel acessar o microfone');
                    return;
                }
            }
            
            isMuted = !isMuted;
            micStream.getAudioTracks()[0].enabled = !isMuted;
            
            const btn = document.getElementById('btn-mic');
            
            if (isMuted) {
                btn.classList.remove('border-green-500', 'text-green-500', 'shadow-[0_0_20px_rgba(0,255,0,0.5)]');
                btn.classList.add('border-red-500', 'text-red-500');
                btn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
            } else {
                btn.classList.remove('border-red-500', 'text-red-500');
                btn.classList.add('border-green-500', 'text-green-500', 'shadow-[0_0_20px_rgba(0,255,0,0.5)]');
                btn.innerHTML = '<i class="fas fa-microphone"></i>';
            }
            
            // Update DB
            if (currentRoom) {
                update(ref(db, `rooms/${currentRoom}/players/${myId}/micOn`), !isMuted);
            }
            
            // Update my label
            const myLabel = document.getElementById(`label-${myId}`);
            if (myLabel) {
                const micStatus = myLabel.querySelector('.mic-status');
                if (micStatus) {
                    micStatus.className = `mic-status ${isMuted ? 'off' : 'on'}`;
                    micStatus.innerHTML = `
                        <i class="fas ${isMuted ? 'fa-microphone-slash' : 'fa-microphone'}"></i>
                        <span>${isMuted ? 'MUDO' : 'AO VIVO'}</span>
                    `;
                }
            }
        };

    </script>
</body>
</html>
